syntax = "proto3";
package influxdata.iox.ingester.v1;
import "influxdata/iox/ingester/v1/datafusion.proto";

// Request from the query service for the data not yet persisted. Serialized as the Ticket value
// for the Arrow Flight doGet request.
message IngesterQueryRequest {
  // Table to search
  string table = 1;

  // Columns the query service is interested in
  repeated string columns = 2;

  // Was start time of the query; now use the one in predicate
  reserved "min_time";
  reserved 3;

  // Was end time of the query; now use the one in predicate
  reserved "max_time";
  reserved 4;

  // Predicate for filtering
  optional Predicate predicate = 5;

  // Was for only returning rows with a sequence number greater than this
  reserved "greater_than_sequence_number";
  reserved 6;

  // Namespace to search
  string namespace = 7;

  // Sequencer to search
  int32 sequencer_id = 8;
}

// Metadata that the ingester provides to the query service along with the results. Serialized
// in the FlightData's app_metadata for the schema that is returned as the first item from the
// Arrow Flight doGet request.
message IngesterQueryResponseMetadata {
  // There was no field 1, oops.
  reserved 1;

  // Was max persisted sequence number of the table
  reserved "max_sequencer_number";
  reserved 2;

  // Max sequence number persisted for this table
  optional int64 parquet_max_sequence_number = 3;

  // Max sequence number for a tombstone associated with this table
  optional int64 tombstone_max_sequence_number = 4;
}

// Serialization of `predicate::predicate::Predicate` that contains DataFusion `Expr`s
message Predicate {
  // Optional field restriction. If any are present, restricts the results to only tables which
  // have *at least one* of the fields in field_columns.
  repeated string field_columns = 1;

  // Optional partition key filter
  optional string partition_key = 2;

  // Optional timestamp range: only rows within this range are included in results. Other rows are
  // excluded.
  optional TimestampRange range = 3;

  // Optional arbitrary predicates, represented as list of DataFusion expressions applied a logical
  // conjunction (aka they are 'AND'ed together). Only rows that evaluate to TRUE for all these
  // expressions should be returned. Other rows are excluded from the results.
  repeated datafusion.LogicalExprNode exprs = 4;

  // Optional arbitrary predicates on the special `_value` column. These expressions are applied to
  // `field_columns` projections in the form of `CASE` statement conditions.
  repeated BinaryExpr value_expr = 5;
}

// Specifies a continuous range of nanosecond timestamps.
message TimestampRange {
  // Start defines the inclusive lower bound.
  int64 start = 1;

  // End defines the exclusive upper bound.
  int64 end = 2;
}

// A representation of the `BinaryExpr` variant of a DataFusion expression for value expressions.
message BinaryExpr {
  datafusion.Column left = 1;
  string op = 2;
  datafusion.LogicalExprNode right = 3;
}
